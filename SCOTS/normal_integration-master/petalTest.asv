% Constants
clear all; close all; clc;
radius = 250;
center = [300, 300];
nrows = 600;
ncols = 600;
n_petals = 6;
theta = linspace(0, 2*pi, n_petals+1); % angles for the petals
tilt = 0.2; % tilt for one of the petals

% Create a grid
[x, y] = meshgrid(1:ncols, 1:nrows);

% Create the mask and depth map
mask = zeros(nrows, ncols);
u = zeros(nrows, ncols);
for i = 1:n_petals
    % Calculate the angle for each point in the grid
    angle = atan2(y-center(2), x-center(1));
    angle(angle<0) = angle(angle<0) + 2*pi;  % Convert negative angles to positive
    
    % Find the pixels inside the current petal
    in_petal = ((x-center(1)).^2 + (y-center(2)).^2 <= radius^2) & ... % inside the outer circle
        ((x-center(1)).^2 + (y-center(2)).^2 > (radius/10)^2) & ... % outside the inner circle
        (angle >= theta(i)) & ... % right of the left boundary
        (angle < theta(i+1)); % left of the right boundary
    
    % Update the mask
    mask(in_petal) = 1;
    
    % Update the depth map
    u(in_petal) = sqrt((x(in_petal)-center(1)).^2 + (y(in_petal)-center(2)).^2);
    
    % Apply the tilt to one of the petals
    if i == 3
        u(in_petal) = u(in_petal) + tilt*(y(in_petal)-center(2));
    end
end

% Add Gaussian noise to the depth map
std_noise = 0.02*max(u(:));
u = u + std_noise*randn(size(u));

% Compute the gradients in the u- and v-directions
[p, q] = gradient(u);
